# Project-CSCI-114-

Description: in this project, you will implement a bounded buffer queue (BBQ) based on Fig. 5.8 in the textbook, where lock variable is used to synchronize the access of queues. 20 threads are created with 10 producers and 10 consumers. The size of the queue MAX should be a constant and can be changed (at of time of testing). Your program should display the following events on screen:  Thread creation Item ID # produced by thread number # Item ID # consumed by thread number # Waiting to produce by thread number # Waiting to consume by thread number # Your program should run with a command "project1 TP TC, where project1 is the executable program, TP represents the "initial" sleep time range limit for producing threads and TC represents the sleep time range limit for consuming threads.

Note: Producers and consumers can control their speed of producing/consuming by changing the sleeping time between two consecutive produce/consume operations. The sleeping interval t should be a random value within a range (0,T). For producers, it should dynamically change its speed of "producing" by changing its sleep time range TP as follows: it should gradually slow down the producing when the buffer is over 75% occupancy and stop producing (with condition variable) when buffer is 100% full. Similarly, it  should gradually accelerate the producing when the buffer is below 25% occupancy and reaches twice the initial average speed when buffer is empty. For consumers, it should maintain the same range TC and stop consuming (with condition variable) when the buffer is empty.

Running environment: Mac

Compiler: C++11

If on XCode directly then you can simply copy and paste the code straight on there and hit the Start button in order to have it run directly on that application, if not then through the terminal as well, for me specifically it ran with the command: "/Users/alexislara/Documents/CSCI\ 114\ \(Year\ 4\ -\ Semester\ 1\)/Project\ \(CSCI\ 114\)/DerivedData/Project\ \(CSCI\ 114\)/Build/Products/Debug/Project\ \(CSCI\ 114\) ; exit;

Link of a brief video that demos the execution of your program
1st entry: https://www.youtube.com/watch?v=s9go_eDVX74 
2nd entry: https://www.youtube.com/watch?v=Ct-q_84qtAM

- For this project, the focus was upon the concept of working with the Bounded Buffer Queue to find the distinct differences in time between the means of TC/TP/Buffer sizes. To explain the main concept in more depth, the main goal of the project is to implement the Bounded Buffer Queue in order to find the differences in time by influencing certain variables to be affected differently than intended. Throughout the implementation of the project, there’ll be the number of threads being used and produced, as well as a number of them also being consumed, and the program will be sure to let us know what happens to each thread as well as the process it goes through. Thus, the implementation of the Bounded Buffer Queue should be able to output the differences in an obvious format in order to observe it properly, in a graphing format, with the overall use of the given Queue involving the Bounded Buffer implementation and the printing function for giving the proper output of the solution in the correct format needed such as the descriptions. 
- For this project, I simply had to build a program that would be able to handle roughly 20 threads with ten comsumers and 10 producers, whilst also managing the values for TP and TC alongside the use of Buffer Sizes. With this program, I would then run the function of Bounded Buffer in order to traverse the threads and find the paths that traverse the means of producing and consuming but also take the least amount of time as it goes about the code, all in order to return the empties and fulls then the output would portray the way the threads went about. So, for this project, I thought it’d be easier to approach it with the use of XCode on mac , since then I would be able to build the source directly, and be able to manage my work better because I don't know and don't have access to the other methods of which to do the project. Overall, I was able to build the functions with the use of many for loops as well, firstly to initialize, then to be able to traverse and relax the threads as to find how they go about producing, consuming, and waiting as the functions ran, and then finally having a for loop to check if there are any cycles in which the threads would loop back or forward in order to fulfill the wait or the full transitions and complete themselves. But, for this question, I was able to make it somewhat easier, since I was able to use the XCode and be more familiar with what I can do, for example I was able to run the bounded buffer implementation in two distinct ways, thus making the project fairly simple and giving an output that can be comparable to what's expected in two separate ways because one outputs information in a slow/fast fashion but displays less whilst the other is more organized and displays more information but doesn't run in a non-stop fashion but has to have a fixed number to go off of.
- From the given videos, we can see the clear difference between the two entries (both within the same .cpp file but just being changed about as one is commented out while the other runs). The first entries output is more descriptive and has a fixed amount of threads to go off of while the second entries output goes to show how it can run non-stop, producing and consuming but it's less descriptive and more like a queue. However, although the code does run and is capable of outputting data that can be understood, I was unable to find a method to time the production and consumption because I don't know how to time the programs given as well as the fact that my programs are distinct in the fact that I wasn't able to implement the method of using TC/TP/Buffer Sizes. So, although the coding itself is complete, the work was still partial in its true intention from the start.
- As for issues throughout the project, the only little problems I really had were building my program to fit the description of the assignment, and I say this because I didn't run it on the terminal the same way the professor demonstrated in class. The program itself was pretty self-explanatory (somewhat vague at times, in terms of what approach to take exactly), but nonetheless the functions themselves were rather simple and easy to figure out, or at least in my case it was since I had used XCode in other occasions for building programs similar to this one. Although, like I was saying, the only issues I had involved the creation of the program to fit the use of TP & TC values since I had to build the program as a whole without messing up the threading and consumption/production for the queue. This turned out to be an issue for a while since the buffer was a bit iffy in this case, where the way the threading and Bounding had to work mattered, but nonetheless, in the end I managed to figure some of what to do and how to cope with what little I had because of the fact that I didn't know how to implement the use of Linux/Unix and how to use the timing capabilities for the threading in a multi-processing fashion.
- From this project, I was able to understand the approach of the Bounded Buffer Queue for the most part, or in this case the way to go about it and its function. I was able to work throughout the functions and see how each bit of initialization works and how each “for” loop does its own part that doesn’t necessarily work together but altogether works towards the same output, or the same goal. So, all in all, the project was very helpful in producing a depiction of what we need to do in order to build a graph, but also to be able to manage an algorithm that allows us to traverse the graph with the least amount of work, mostly in the case of travelling from one thread to another and have the minimal amount of time altogether in the end, and with this knowledge we can then end up applying this know-how to other things that allow us to connect with greater things such as traversal in a means that’s faster or slower, and maybe on a graph that has a way of showing distinctions between the values of which we can change for the threading itself. Therefore, I believe this project to be very helpful in understanding better how the Bounded Buffer Queue works and how to build it with a better mindset and approach since now I not only have the functions themselves but also the program for it that partially works.
-	For the project though, I was only using the functions based on how we should format the program itself, brought by the professor during lectures, the actual lecture notes that describe the procedure itself, from the professors notes, and finally, using past lab works that involve the use of threading in order to build structures for the production of threads; overall making it easier to understand how to build certain parts of a project and making it simpler to change and alter in accordance to the original outlines provided by the main lecture and the given notes to refer to.
